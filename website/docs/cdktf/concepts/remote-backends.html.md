---
layout: "docs"
page_title: "Remote Backends"
sidebar_current: "cdktf"
description: "TODO: describe me"
---

# Remote Backends

Terraform stores [state](https://www.terraform.io/docs/language/state/index.html) about managed infrastructure to map real-world resources to the configuration, keep track of metadata, and improve performance. Terraform stores this state in a local file by default, but you can also use a Terraform [remote backend](https://www.terraform.io/docs/backends/types/remote.html) to store state remotely.

You can configure your remote backend to be [Terraform Cloud](https://www.terraform.io/docs/cloud/index.html), another Terraform (CDKTF) [supported backend](#supported-backends), or a custom location.

## When to Use Remote Backends

Consider using a remote backend when multiple individuals or teams need access to your infrastructure state data.

[Remote state](https://www.terraform.io/docs/language/state/remote.html) makes it easier for teams to work together because all members have access to the latest state data in the remote store. It also allows you to share output values with other configurations, allowing groups to share infrastructure resources. For example, a core infrastructure team can handle building the core machines, networking, etc. and can expose some information to other teams to run their own infrastructure.

## Define Remote Backends

You can define a [JSON configuration for a remote backend](https://www.terraform.io/docs/configuration/syntax-json.html#terraform-blocks)
with a `TerraformBackend` subclass or a JSON configuration file.

### `TerraformBackend` Subclass

A `TerraformBackend` subclass like `RemoteBackend` below synthesizes to the required remote backend JSON configuration in the autogenerated `cdk.tf.json` file.

```typescript
import { Construct } from "constructs";
import { App, TerraformStack, TerraformOutput } from "cdktf";

class MyStack extends TerraformStack {
  constructor(scope: Construct, id: string) {
    super(scope, id);

    new RemoteBackend(this, {
      hostname: "app.terraform.io",
      organization: "company",
      workspaces: {
        name: "my-app-prod",
      },
    });

    new TerraformOutput(this, "dns-server", {
      value: "hello-world",
    });
  }
}

const app = new App();
new Mystack(app, "hello-terraform");
```

Synthesizing this app will create a JSON file called `remote.tf.json` in the `cdktf.out` stack sub-directory containing the synthesized CDKTF code.

For example for a stack called `hello-terraform`, this would create its ouptut in `cdktf.out/stacks/hello-terraform`. This directory contains the synthesized code that CDKTF generates when you run `cdktf synth`.

```bash
cd cdktf.out/stacks/hello-terraform
vim remote.tf.json
```

```json
{
  "terraform": {
    "backend": {
      "remote": {
        "hostname": "app.terraform.io",
        "organization": "company",
        "workspaces": {
          "name": "my-app-prod"
        }
      }
    }
  }
}
```

The stack output directory is as follows.

```bash
tree .
.
├── cdk.tf.json
└── remote.tf.json
```

## Initialize Remote Backends

By default, all `cdktf` operations will do an automatic `terraform init` behind the scenes. There might be cases where an interactive `init` is necessary. In these cases, it's possible to fallback to the Terraform CLI. Find the corresponding stack output directory in the `cdktf.out` folder and do the following:

Run `terraform init` to initialize a Terraform remote backend.

```shell
$ cd cdkf.out/stacks/hello-terraform
$ terraform init
```

## Migrate Local State Storage to Remote

In case of local state files being present, it's possible to switch to a remote backend and migrate the existing state.

After you define your remote backend, you need to move the Terraform state file to the CDK for Terraform output directory.

Consider this example project called `hello-terraform` that is using local storage to store the Terraform state.

```bash
cd hello-terraform
```

Add remote state backend using TerraformBackend.

```bash
vim main.ts
```

```typescript
const stack = new MyStack(app, "hello-terraform");
new RemoteBackend(stack, {
  hostname: "app.terraform.io",
  organization: "company",
  workspaces: {
    name: "my-app-prod",
  },
});
```

Synthesize application.

```bash
cdktf synth
```

Move Terraform state file into the output directory.

```bash
mv terraform.hello-terraform.tfstate cdktf.out/stacks/hello-terraform
```

Run Terraform init.

```bash
cd cdktf.out/stacks/hello-terraform
terraform init


Initializing the backend...
Do you want to copy existing state to the new backend?
  Pre-existing state was found while migrating the previous "local" backend to the
  newly configured "remote" backend. No existing state was found in the newly
  configured "remote" backend. Do you want to copy this state to the new "remote"
  backend? Enter "yes" to copy and "no" to start with an empty state.

  Enter a value: yes


Successfully configured the backend "remote"! Terraform will automatically
use this backend unless the backend configuration changes.

Initializing provider plugins...

.....
Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.

```

Validate state migration by running the `cdktf diff` command in the root `hello-terraform`

```bash
cd ../../..
```

```bash
cdktf diff
```

There are no changes to the stack. Given that there are resources within the stack, a new backend would create a diff if the state wouldn't have been migrated. Please consult the docs for the backend type which is used how to verify in detail that the state is has been migrated successfully.

```bash
Stack: hello-terraform

Diff: 0 to create, 0 to update, 0 to delete.

```

# Supported Backends

In addition to Terraform Cloud, Terraform and CDKTF support the following backends.

- [local](https://www.terraform.io/docs/backends/types/local.html)
  ```typescript
  new LocalBackend(stack, {...});
  ```
- [artifactory](https://www.terraform.io/docs/backends/types/artifactory.html)
  ```typescript
  new ArtifactoryBackend(stack, {...});
  ```
- [azurerm](https://www.terraform.io/docs/backends/types/azurerm.html)
  ```typescript
  new AzurermBackend(stack, {...});
  ```
- [consul](https://www.terraform.io/docs/backends/types/consul.html)
  ```typescript
  new ConsulBackend(stack, {...});
  ```
- [cos](https://www.terraform.io/docs/backends/types/cos.html)
  ```typescript
  new CosBackend(stack, {...});
  ```
- [etcd](https://www.terraform.io/docs/backends/types/etcd.html)
  ```typescript
  new EtcdBackend(stack, {...});
  ```
- [etcdv3](https://www.terraform.io/docs/backends/types/etcdv3.html)
  ```typescript
  new EtcdV3Backend(stack, {...});
  ```
- [gcs](https://www.terraform.io/docs/backends/types/gcs.html)
  ```typescript
  new GcsBackend(stack, {...});
  ```
- [http](https://www.terraform.io/docs/backends/types/http.html)
  ```typescript
  new HttpBackend(stack, {...});
  ```
- [manta](https://www.terraform.io/docs/backends/types/manta.html)
  ```typescript
  new MantaBackend(stack, {...});
  ```
- [oss](https://www.terraform.io/docs/backends/types/oss.html)
  ```typescript
  new OssBackend(stack, {...});
  ```
- [pg](https://www.terraform.io/docs/backends/types/pg.html)
  ```typescript
  new PgBackend(stack, {...});
  ```
- [s3](https://www.terraform.io/docs/backends/types/s3.html)
  ```typescript
  new S3Backend(stack, {...});
  ```
- [swift](https://www.terraform.io/docs/backends/types/swift.html)
  ```typescript
  new SwiftBackend(stack, {...});
  ```

## Escape Hatches

[Escape hatches](docs/working-with-cdk-for-terraform/escape-hatch.md) are objects that can add to or override existing resources. You can use them for backends or backend constructs that CDKTF does not natively support.

Below is an example which uses an Escape Hatch to configure unsupported backends on a Stack object.

```typescript
stack.addOverride("terraform.backend", {
  atlas: {
    name: "example_corp/networking-prod",
    address: "https://app.terraform.io",
  },
});
```
