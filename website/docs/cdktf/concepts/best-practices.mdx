---
page_title: "Best Practices"
description: "We discuss patterns and strategies for building and maintaining infrastructure with CDKTF."
---

# Best Practices

## Use `TerraformVariable` to read secrets

If you read a secret from the environment or out of a file with normal file system access and you use it in your CDKTF code, it will end up in the synthesized Terraform code. The problem with that is that it might leak if an attacker can get access to your Terraform code. To mitigate this, you should [use the `TerraformVariable` construct](/cdktf/concepts/variables-and-outputs#input-variables) to read secrets.

## Use pre-built provider bindings if possible

Pre-built provider bindings are available for many popular providers, they have the same code as if you'd run `cdktf get` for this provider. [You can find a complete list through Github](https://github.com/orgs/hashicorp/repositories?q=cdktf-provider-). They help you by reducing the time `cdktf get` takes and they can be used as a peer dependency if you use open source custom constructs.

## Build extensible constructs

No matter if you are building constructs for your organization or as open source code: Constructs are a great way to abstract common behaviour into reusable classes. If you have no reason to limit the extensibility of a construct you should default to making it as easy to the user as possible to overwrite custom behaviour, while still providing good defaults for the standard behaviour.
You can use interfaces from the generated provider bindings to allow users to overwrite configuration you write if the number of configurations is limited enough.
In very complex constructs it can be useful to encapsulate overwritable behaviour into methods. This way a user can extend the base class and overwrite the behaviour in a single place.

```ts
import { Construct } from "constructs";
import { S3Bucket, S3BucketConfig } from "@cdktf/provider-aws/lib/s3";

class MyS3Bucket extends Construct {
  constructor(
    protected scope: Construct,
    protected id: string,
    protected s3Options: S3BucketConfig
  ) {
    super(scope, id);
    new s3.Bucket(this, "MyBucket", {
      ...s3Options,
      bucketName: this.getBucketName(),
      versioned: true,
    });
  }

  public getBucketName() {
    return this.s3Options.bucketName || `${this.id}-bucket`;
  }
}

class SimpleS3Bucket extends MyS3Bucket {
  // New behaviour was patched in by overwriting
  public getBucketName() {
    return this.id;
  }
}
```

## Use projen to distribute constructs

If your code is hosted on Github and you want to distribute it as a CDKTF construct, you can use [projen](https://github.com/projen/projen) to create a repository with all required tooling set up for you. You can run `npx projen new cdktf-construct` in a new folder and the created project will be ready to use. Projen has builtin options to [publish constructs to all registries](https://github.com/projen/projen/blob/main/src/cdk/jsii-project.ts#L48).

If you want to deploy your CDKTF construct as a Terraform module we recommend checking out [`projen-cdktf-hybrid-construct`](https://github.com/DanielMSchmidt/projen-cdktf-hybrid-construct).

## Seperate business units in stacks

When it comes to the question where to split stacks we recommend making a cut between

- different deployment stages (development / staging / production)
- different applications (e-commerce / blog / data warehouse)
- different regions (eu-west-1 / us-east-1) if they deploy similar infrastructure, e.g. for high availability
- different layers of your stack (network / db / compute)
- different deployment cycles (databases and domain names / applications)

While each application should be it's own stack, deployment stages and regions can be passed as arguments to the stack. This way you share the benefit of quickly changing the logic (you only need to write the code once), but you maintain a clear seperation and a small blast radius.
