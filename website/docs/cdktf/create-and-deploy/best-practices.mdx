---
page_title: "Application Best Practices"
description: Build robust CDKTF applications. How to manage secrets, build constructs, design stacks, and more.
---

# Best Practices

## Secrets

### Use Terraform Variables to Read Secrets

Secrets appear in your synthesized CDKTF code when you read them directly from environment variables or from files with normal system access. This introduces risk, especially if you are checking the synthesized configuration into a version control system. To mitigate this, [use the `TerraformVariable` construct](/cdktf/concepts/variables-and-outputs#input-variables) to read secrets.

TODO: Can you provide a quick code example?

TODO: Are there any instances where they can't use TerraformVariable for secrets? IN those cases, what do we recommend?

TODO: Why? Does TerraformVariable know now to print them? Do they get transformed before the code is synthesized? Can we explain why this is ssafer?

### Use Terraform Cloud to Manage Secrets

TODO: Can you draft some content about how folks can use Terraform Cloud and how it's  helpful for secrets? I'm assuming it's because of things like Variable Sets and the fact that you can keep variables in Terraform Cloud workspaces, outside of version control and/or your Terraform config entirely?

## Providers

Use pre-built providers when possible. Pre-built provider bindings have the equivalent code to running `cdktf get`, reducing the time it takes to synthesize and run your application. You can also use pre-built providers as a peer dependency if you use open-source custom constructs.

Refer to the [CDKTF Provider GitHub repositories](https://github.com/orgs/hashicorp/repositories?q=cdktf-provider-) for a complete list of available pre-built providers.

## Application Architecture

### Create Extensible Constructs

No matter if you are building constructs for your organization or as open source code: Constructs are a great way to abstract common behaviour into reusable classes. If you have no reason to limit the extensibility of a construct you should default to making it as easy to the user as possible to overwrite custom behaviour, while still providing good defaults for the standard behaviour.
You can use interfaces from the generated provider bindings to allow users to overwrite configuration you write if the number of configurations is limited enough.
In very complex constructs it can be useful to encapsulate overwritable behaviour into methods. This way a user can extend the base class and overwrite the behaviour in a single place.

```ts
import { Construct } from "constructs";
import { S3Bucket, S3BucketConfig } from "@cdktf/provider-aws/lib/s3";

class MyS3Bucket extends Construct {
  constructor(
    protected scope: Construct,
    protected id: string,
    protected s3Options: S3BucketConfig
  ) {
    super(scope, id);
    new s3.Bucket(this, "MyBucket", {
      ...s3Options,
      bucketName: this.getBucketName(),
      versioned: true,
    });
  }

  public getBucketName() {
    return this.s3Options.bucketName || `${this.id}-bucket`;
  }
}

class SimpleS3Bucket extends MyS3Bucket {
  // New behaviour was patched in by overwriting
  public getBucketName() {
    return this.id;
  }
}
```

### Create a Stack for Each Business Unit

When it comes to the question where to split stacks we recommend making a cut between

- different deployment stages (development / staging / production)
- different applications (e-commerce / blog / data warehouse)
- different regions (eu-west-1 / us-east-1) if they deploy similar infrastructure, e.g. for high availability
- different layers of your stack (network / db / compute)
- different deployment cycles (databases and domain names / applications)

While each application should be it's own stack, deployment stages and regions can be passed as arguments to the stack. This way you share the benefit of quickly changing the logic (you only need to write the code once), but you maintain a clear seperation and a small blast radius.

## Constructs

### Use Projen to Distribute Constructs

If your code is hosted on Github and you want to distribute it as a CDKTF construct, you can use [projen](https://github.com/projen/projen) to create a repository with all required tooling set up for you. You can run `npx projen new cdktf-construct` in a new folder and the created project will be ready to use. Projen has builtin options to [publish constructs to all registries](https://github.com/projen/projen/blob/main/src/cdk/jsii-project.ts#L48).

If you want to deploy your CDKTF construct as a Terraform module we recommend checking out [`projen-cdktf-hybrid-construct`](https://github.com/DanielMSchmidt/projen-cdktf-hybrid-construct).
