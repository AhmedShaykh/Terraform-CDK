---
page_title: "Best Practices"
description: Build robust applications for production use cases. How to manage secrets, build constructs, design stacks, and more.
---

# CDK for Terraform Best Practices

TODO - we need an introduction. Is this to help folks build production applications? I think we need to say something about how CDKTF is extremely flexible, but that we recommend the following to build robust production-ready applications.

## Secrets

### Read Secrets with Terraform Variables

Secrets appear in your synthesized CDKTF code when you read them directly from environment variables or from files with normal system access. This introduces risk, especially if you are checking the synthesized configuration into a version control system. To mitigate this, [use the `TerraformVariable` construct](/cdktf/concepts/variables-and-outputs#input-variables) to read secrets.

TODO: Can you provide a quick code example?

TODO: Are there any instances where they can't use TerraformVariable for secrets? IN those cases, what do we recommend?

TODO: Why? Does TerraformVariable know now to print them? Do they get transformed before the code is synthesized? Can we explain why this is ssafer?

### Manage Secrets with Terraform Cloud

TODO: Can you draft some content about how folks can use Terraform Cloud and how it's  helpful for secrets? I'm assuming it's because of things like Variable Sets and the fact that you can keep variables in Terraform Cloud workspaces, outside of version control and/or your Terraform config entirely?

## Providers

A provider is a Terraform plugin that allows users to manage an external API. Provider plugins like the AWS provider or the cloud-init provider act as a translation layer that allows Terraform to communicate with many different cloud providers, databases, and services.

Use [pre-built providers](/cdktf/concepts/providers-and-resources#install-pre-built-providers) when possible. It can take several minutes to generate the code bindings for providers with very large schemas, so we offer several popular providers as pre-built packages. Pre-built providers are a performance optimization that reduces the time it takes to synthesize and run your application. You can also use pre-built providers as a peer dependency if you use open-source custom constructs.

Refer to the [CDKTF Provider GitHub repositories](https://github.com/orgs/hashicorp/repositories?q=cdktf-provider-) for a complete list of pre-built providers.

## Application Architecture

### Separate Business Units with Stacks

A [stack](/cdktf/concepts/stacks) represents a collection of infrastructure that CDK for Terraform (CDKTF) synthesizes as a dedicated Terraform configuration. Stacks allow you to separate the state management for multiple environments within an application. We recommend creating separate stacks for the following use cases:

- Deployment stages (development / staging / production)
- Business Purposes (e-commerce / blog / data warehouse)
- Regions (eu-west-1 / us-east-1) if they deploy similar infrastructure, e.g. for high availability
- Software components (network / db / compute)
- Deployment cycles (databases and domain names / applications)

While each application should be its own stack, deployment stages and regions can be passed as arguments to the stack. This way you share the benefit of quickly changing the logic (you only need to write the code once), but you maintain a clear seperation and a small blast radius.

TODO: What do you mean by "Each application should be its own stack?"
TODO: Do we actually need to separate this out? It's sounding like we may need to clarify when we actually need SEPARATE stacks vs. when we can have one stack but pass in different parameters (e.g. deployment stages, regions, etc.)

TODO: Could we have a simple example of a single stack where we pass in different params for region, etc.? Also do we have any existing multi-stack examples where we can link folks to show a use case?

### Create Extensible Constructs

[Constructs](/cdktf/concepts/constructs) let you abstract common behaviour into reusable classes. If you have no reason to limit the extensibility of a construct you should default to making it as easy to the user as possible to overwrite custom behaviour, while still providing good defaults for the standard behaviour.

You can use interfaces from the generated provider bindings to allow users to overwrite configuration you write if the number of configurations is limited enough. In very complex constructs, we recommend using methods to encapsulate behaviour that the user can overwrite. This lets users extend the base class and overwrite the behaviour in a single place.

TODO: Is there an example of the above? (or even can we give a description of a use case "For example, you could encapsulate XX behavior into a method...")

TODO: Please describe what's going on in this example. "The following example..."

```ts
import { Construct } from "constructs";
import { S3Bucket, S3BucketConfig } from "@cdktf/provider-aws/lib/s3";

class MyS3Bucket extends Construct {
  constructor(
    protected scope: Construct,
    protected id: string,
    protected s3Options: S3BucketConfig
  ) {
    super(scope, id);
    new s3.Bucket(this, "MyBucket", {
      ...s3Options,
      bucketName: this.getBucketName(),
      versioned: true,
    });
  }

  public getBucketName() {
    return this.s3Options.bucketName || `${this.id}-bucket`;
  }
}

class SimpleS3Bucket extends MyS3Bucket {
  // New behaviour was patched in by overwriting
  public getBucketName() {
    return this.id;
  }
}
```

### Use Projen to Distribute Constructs

If your code is hosted on Github and you want to distribute it as a CDKTF construct, you can use [projen](https://github.com/projen/projen) to create a repository with all required tooling set up for you. You can run `npx projen new cdktf-construct` in a new folder and the created project will be ready to use. Projen has builtin options to [publish constructs to all registries](https://github.com/projen/projen/blob/main/src/cdk/jsii-project.ts#L48).

If you want to deploy your CDKTF construct as a Terraform module, we recommend [`projen-cdktf-hybrid-construct`](https://github.com/DanielMSchmidt/projen-cdktf-hybrid-construct).
