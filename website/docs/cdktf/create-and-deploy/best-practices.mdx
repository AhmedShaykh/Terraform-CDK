---
page_title: "Best Practices"
description: Build robust applications for production use cases. How to manage secrets, build constructs, design stacks, and more.
---

# CDK for Terraform Best Practices

How your CDK application should be structured is largely depending on the engineering best practices of the programming language you use. There is no one way to structure your CDK application, what works for you and your team also depends on the problems you are trying to solve. So instead of one golden way we list here a set of best practices to follow when building production-ready CDK applications.

## Read Secrets with Terraform Variables

Secrets appear in your synthesized CDKTF code when you read them directly from environment variables or from files with normal system access. This introduces risk, especially if you are checking the synthesized configuration into a version control system. To mitigate this, [use the `TerraformVariable` construct](/cdktf/concepts/variables-and-outputs#input-variables) to read secrets.

```ts
const adminPassword = new TerraformVariable(this, "adminPassword", {
  type: "string",
  description: "Admin password for the instance",
  sensitive: true,
});
new MyResource(this, "hello", {
  adminPassword: adminPassword.value, // use this instead of process.env.ADMIN_PASSWORD
});
```

In the example above if we had used `adminPassword: process.env.ADMIN_PASSWORD` the admin password environment variable set at synthesization time would have been written to the `cdk.tf.json` file for your stack. This would have been a security risk.

In contrast the `TerraformVariable` construct synthesizes a Terraform input. This input is not written to the `cdk.tf.json` file, so it is not a security risk. Instead it's only used at execution time by Terraform directly.

To pass a [Terraform variable through environment variables](/cli/config/environment-variables#tf_var_name) you would need to set `TF_VAR_adminPasword='<your password>'` in the execution environment.

If you use Terraform Cloud with [remote execution](/cloud-docs/run#remote-operations) turned on you can store your secrets in Terraform Cloud. You can read more information about this in the [Terraform Cloud documentation](/cloud-docs/workspaces/variables/managing-variables#workspace-specific-variables).

## Providers

A provider is a Terraform plugin that allows users to manage an external API. Provider plugins like the AWS provider or the cloud-init provider act as a translation layer that allows Terraform to communicate with many different cloud providers, databases, and services.

Use [pre-built providers](/cdktf/concepts/providers-and-resources#install-pre-built-providers) when possible. It can take several minutes to generate the code bindings for providers with very large schemas, so we offer several popular providers as pre-built packages. Pre-built providers are a performance optimization that reduces the time it takes to synthesize and run your application. You can also use pre-built providers as a peer dependency if you use open-source custom constructs.

Refer to the [CDKTF Provider GitHub repositories](https://github.com/orgs/hashicorp/repositories?q=cdktf-provider-) for a complete list of pre-built providers.

## Application Architecture

### Separate Business Units with Stacks

A [stack](/cdktf/concepts/stacks) represents a collection of infrastructure that CDK for Terraform (CDKTF) synthesizes as a dedicated Terraform configuration. Stacks allow you to separate the state management for multiple environments within an application. We recommend creating separate stacks for the following use cases:

- Deployment stages (development / staging / production)
- Business Purposes (e-commerce / blog / data warehouse)
- Regions (eu-west-1 / us-east-1) if they deploy similar infrastructure, e.g. for high availability
- Software components (network / db / compute)
- Deployment cycles (databases and domain names / applications)

While each of the criterias above warants a new stack, not all of them justify a new class for the stack.
Deployment stages and regions can be passed as arguments to the constructor of the stack class. All other criterias most likely influence the infrastructure of the stack by a degree that justifies a new stack class.

Your CDKTF entrypoint might look like this:

```ts
const devNetworking = new NetworkingStack(this, "networking-development", {
  // ...
});

// A development environment for each of our products, a single region is enough
new Ecommerce(this, "ecommerce-development", {
  vpcId: devNetworking.vpcId,
  subnets: devNetworking.subnets,
  region: "us-west-1",
});
new Blog(this, "ecommerce-development", {
  vpcId: devNetworking.vpcId,
  subnets: devNetworking.subnets,
  region: "us-west-1",
});

// For our staging environments we want to have two ecommerce stacks in different regions
// to test the high availability features of our infrastructure
const stageNetworking = new NetworkingStack(this, "networking-staging", {
  // ...
});
const ecommerceStaging = new Ecommerce(this, "ecommerce-staging-us", {
  vpcId: stageNetworking.vpcId,
  subnets: stageNetworking.subnets,
  region: "us-west-1",
});
new Ecommerce(this, "ecommerce-staging-eu", {
  vpcId: stageNetworking.vpcId,
  subnets: stageNetworking.subnets,
  region: "eu-central-1",
  databaseReplicationMaster: ecommerceStaging.databaseReplicationMaster,
});
new Blog(this, "ecommerce-staging", {
  vpcId: stageNetworking.vpcId,
  subnets: stageNetworking.subnets,
  region: "us-west-1",
});
```

### Create Extensible Constructs

[Constructs](/cdktf/concepts/constructs) let you abstract common behaviour into reusable classes. If you have no reason to limit the extensibility of a construct you should default to making it as easy to the user as possible to overwrite custom behaviour, while still providing good defaults for the standard behaviour.

You can use interfaces from the generated provider bindings to allow users to overwrite configuration you write if the number of configurations is limited enough. In very complex constructs, we recommend using methods to encapsulate behaviour that the user can overwrite. This lets users extend the base class and overwrite the behaviour in a single place.

For example you can move behaviour where you derive default values from config values into methods, so that this logic is easily overwritable by users.

In this example we expose configuration options for the S3 bucket resource our construct contains.
We also create a second construct class that overwrites the default naming behaviour as an example on how behaviour can be changed.

```ts
import { Construct } from "constructs";
import { S3Bucket, S3BucketConfig } from "@cdktf/provider-aws/lib/s3";

class MyS3Bucket extends Construct {
  constructor(
    protected scope: Construct,
    protected id: string,
    protected s3Options: S3BucketConfig
  ) {
    super(scope, id);
    new s3.Bucket(this, "MyBucket", {
      ...s3Options,
      bucketName: this.getBucketName(),
      versioned: true,
    });
  }

  public getBucketName() {
    return this.s3Options.bucketName || `${this.id}-bucket`;
  }
}

class SimpleS3Bucket extends MyS3Bucket {
  // New behaviour was patched in by overwriting
  public getBucketName() {
    return this.id;
  }
}
```

### Use Projen to Distribute Constructs

If your code is hosted on Github and you want to distribute it as a CDKTF construct, you can use [projen](https://github.com/projen/projen) to create a repository with all required tooling set up for you. You can run `npx projen new cdktf-construct` in a new folder and the created project will be ready to use. Projen has builtin options to [publish constructs to all registries](https://github.com/projen/projen/blob/main/src/cdk/jsii-project.ts#L48).

If you want to deploy your CDKTF construct as a Terraform module, we recommend [`projen-cdktf-hybrid-construct`](https://github.com/DanielMSchmidt/projen-cdktf-hybrid-construct).
