// uses the functions.json file to generate the bindings for CDKTF

import fs from "fs/promises";
import * as path from "path";
import { AttributeType } from "@cdktf/provider-generator";
import generate from "@babel/generator";
import template from "@babel/template";
import * as t from "@babel/types";
import prettier from "prettier";
import { FUNCTIONS_METADATA_FILE } from "./fetch-metadata";

const ts = template({ plugins: [["typescript", {}]] });

const OUTPUT_FILE = path.resolve(
  __dirname,
  "..",
  "..",
  "..",
  "packages",
  "cdktf",
  "lib",
  "terraform-functions.generated.ts"
);

type Parameter = { name: string; type: AttributeType };
type FunctionSignature = {
  description: string;
  return_type: AttributeType;
  parameters: Parameter[];
  variadic_parameter: Parameter;
};

const IMPORTS = ts`
import {
  anyValue,
  asAny,
  asBoolean,
  asList,
  asNumber,
  asString,
  listOf,
  mapValue,
  numericValue,
  stringValue,
  terraformFunction,
} from "./terraform-functions";
`() as t.Statement;
t.addComment(
  IMPORTS,
  "leading",
  `\n * This file is generated by tools/generate-funtion-bindings.
 * To update this file execute 'yarn run generate-function-bindings' in the root of the repository
 `,
  false
);

async function fetchMetadata() {
  const file = path.join(__dirname, FUNCTIONS_METADATA_FILE);
  const json = JSON.parse((await fs.readFile(file)).toString())
    .function_signatures as {
    [name: string]: FunctionSignature;
  };

  const staticMethods = Object.entries(json)
    .sort(fakeSameSortOrderAsExistingFile)
    .map(([name, signature]) => renderStaticMethod(name, signature));

  const fnClass = t.exportNamedDeclaration(
    t.classDeclaration(t.identifier("Fn"), null, t.classBody(staticMethods))
  );
  t.addComment(
    fnClass,
    "leading",
    " eslint-disable-next-line jsdoc/require-jsdoc",
    true
  );

  const program = t.program([IMPORTS, fnClass]);

  const code = prettier.format(generate(program as any).code, {
    parser: "babel",
  });

  await fs.writeFile(OUTPUT_FILE, code);
}

// TODO: special case handlings:
// bcrypt() -> want: "cost?: number" but schema does not help here (related: https://github.com/hashicorp/terraform/blob/6ab3faf5f65a90ae1e5bd0625fa9e83c0b34c5e1/internal/lang/funcs/crypto.go#L115-L117)

function renderStaticMethod(
  name: string,
  signature: FunctionSignature
): t.ClassMethod {
  let returnType = "";
  switch (signature.return_type) {
    case "number":
      returnType = "asNumber";
      break;
    case "string":
      returnType = "asString";
      break;
    case "bool":
      returnType = "asBoolean";
      break;
    case "dynamic":
      returnType = "asAny"; // TODO: this was no wrapping but now is asAny (BREAKING, as it used to return IResolvable but now returns any)
      break;
    default:
      if (
        Array.isArray(signature.return_type) &&
        (signature.return_type[0] === "list" ||
          signature.return_type[0] === "set")
      ) {
        returnType = "asList";
      } else if (
        Array.isArray(signature.return_type) &&
        signature.return_type[0] === "map"
      ) {
        returnType = "asAny";
      } else {
        throw new Error(
          `Function ${name} has unsupported return type: ${JSON.stringify(
            signature.return_type
          )}`
        );
      }
  }

  const mapParameter = (p: Parameter) => {
    let name = p.name;
    if (name === "default") name = "defaultValue";

    const parseType = (
      type: AttributeType
    ): { mapper: string; tsType: t.TSType; docstringType: string } => {
      if (type === "number") {
        return {
          mapper: "numericValue",
          tsType: t.tsNumberKeyword(),
          docstringType: "number",
        };
      } else if (type === "string") {
        return {
          mapper: "stringValue",
          tsType: t.tsStringKeyword(),
          docstringType: "string",
        };
      } else if (type === "bool") {
        return {
          mapper: "anyValue",
          tsType: t.tsAnyKeyword(), // we can't use booleans here as we don't have boolean tokens but need to support token values too
          docstringType: "any",
        };
      } else if (type === "dynamic") {
        return {
          mapper: "anyValue",
          tsType: t.tsAnyKeyword(),
          docstringType: "any",
        };
      } else if (
        Array.isArray(type) &&
        type[0] === "list" &&
        (type[1] === "dynamic" || type[1] === "bool" || type[1] === "number")
      ) {
        const child = parseType(type[1]);
        return {
          mapper: `listOf(${child.mapper})`,
          tsType: t.tsArrayType(child.tsType),
          docstringType: `Array<${child.docstringType}>`,
        };
      } else if (
        Array.isArray(type) &&
        type[0] === "list" &&
        type[1] === "string" // TODO: this branch is similar to the other ones
      ) {
        return {
          mapper: "listOf(anyValue)", // TODO: used like this today, but why,
          tsType: t.tsArrayType(t.tsStringKeyword()),
          docstringType: "Array",
        };
      } else if (
        Array.isArray(type) &&
        type[0] === "list" &&
        Array.isArray(type[1]) &&
        type[1][0] === "list" &&
        type[1][1] === "string" // TODO: this should be handled in a more generic way
      ) {
        // TODO: this case mainly stems from the variadic parameter for join(sep, ...value)
        // which takes more than one list – as JSII doesn't support variadic params, we only support
        // one list in our current implementation of tf functions – so this is breaking and we'll need
        // a special case or override for this and then we can get rid of this case
        return {
          mapper: "listOf(listOf(anyValue))", // TODO: used like this today, but why?
          tsType: t.tsArrayType(t.tsArrayType(t.tsStringKeyword())),
          docstringType: "Array",
        };
      } else if (
        Array.isArray(type) &&
        type[0] === "set" &&
        type[1] === "dynamic"
      ) {
        return {
          mapper: "listOf(anyValue)",
          tsType: t.tsArrayType(t.tsAnyKeyword()),
          docstringType: "Array",
        };
      } else if (
        Array.isArray(type) &&
        type[0] === "list" &&
        Array.isArray(type[1]) &&
        type[1][0] === "set" &&
        type[1][1] === "dynamic" // TODO: this should be handled in a more generic way
      ) {
        // TODO: this case mainly stems from the variadic parameter for setintersection(first, ...otherSets)
        // which takes more than one set – as JSII doesn't support variadic params, we only support
        // one list of sets in our current implementation of tf functions – so this is breaking and we'll need
        // a special case or override for this and then we can get rid of this case
        return {
          mapper: "listOf(anyValue)",
          tsType: t.tsArrayType(t.tsAnyKeyword()),
          docstringType: "Array",
        };
      } else if (
        Array.isArray(type) &&
        type[0] === "map" &&
        Array.isArray(type[1]) &&
        type[1][0] === "list" &&
        type[1][1] === "string" // TODO: this should be handled in a more generic way
      ) {
        return {
          mapper: "mapValue",
          tsType: t.tsAnyKeyword(),
          docstringType: "Object",
        };
      } else {
        throw new Error(
          `Function ${name} has parameter ${
            p.name
          } with unsupported type ${JSON.stringify(p.type)}`
        );
      }
    };

    const { docstringType, mapper, tsType } = parseType(p.type);

    const tsParam = t.identifier(name);
    tsParam.typeAnnotation = t.tsTypeAnnotation(tsType);

    return { name, mapper, tsParam, docstringType };
  };

  const parameters = (signature.parameters || []).map(mapParameter);

  if (signature.variadic_parameter) {
    parameters.push(
      mapParameter({
        ...signature.variadic_parameter,
        type: ["list", signature.variadic_parameter.type], // we can't use variadic parameters with JSII, so we treat this as a list parameter
      })
    );
  }

  // we need a space (Prettier will remove it) as somehow ts`` works in weird ways when
  // passing an empty (or falsy value in the template string)
  const argValueMappers: string =
    parameters.map((p) => p.mapper).join(",") || " ";
  const argNames: string = parameters.map((p) => p.name).join(",");
  const params: any[] = parameters.map((p) => p.tsParam);

  const body = ts`
  return ${returnType}(terraformFunction("${name}", [${argValueMappers}])(${argNames}));
  `();

  const sanitizedFunctionName = name === "length" ? "lengthOf" : name;

  const method = t.classMethod(
    "method",
    t.stringLiteral(sanitizedFunctionName),
    params,
    t.blockStatement(Array.isArray(body) ? body : [body]),
    false, // computed
    true // static
  );

  // comment with docstring for method
  const descriptionWithLink = signature.description.replace(
    `\`${name}\``,
    `{@link https://www.terraform.io/docs/language/functions/${name}.html ${name}}`
  );
  t.addComment(
    method,
    "leading",
    [
      "*",
      `* ${descriptionWithLink}`,
      ...parameters.map((p) => ` * @param {${p.docstringType}} ${p.name}`),
      "",
    ].join("\n")
  );

  return method;
}

fetchMetadata();

const old = [
  "alltrue",
  "anytrue",
  "chunklist",
  "coalesce",
  "coalescelist",
  "compact",
  "concat",
  "contains",
  "distinct",
  "element",
  "flatten",
  "index",
  "keys",
  "length",
  "lookup",
  "matchkeys",
  "mergeLists",
  "mergeMaps",
  "one",
  "range",
  "reverse",
  "setintersection",
  "setproduct",
  "setsubtract",
  "setunion",
  "slice",
  "sort",
  "sum",
  "transpose",
  "values",
  "zipmap",
  "base64sha256",
  "base64sha512",
  "bcrypt",
  "filebase64sha256",
  "filebase64sha512",
  "filemd5",
  "filesha1",
  "filesha256",
  "filesha512",
  "md5",
  "rsadecrypt",
  "sha1",
  "sha256",
  "sha512",
  "uuid",
  "uuidv5",
  "formatdate",
  "timeadd",
  "timestamp",
  "base64decode",
  "base64encode",
  "base64gzip",
  "csvdecode",
  "jsondecode",
  "jsonencode",
  "textdecodebase64",
  "textencodebase64",
  "urlencode",
  "yamldecode",
  "yamlencode",
  "abspath",
  "dirname",
  "pathexpand",
  "basename",
  "file",
  "fileexists",
  "fileset",
  "filebase64",
  "templatefile",
  "cidrhost",
  "cidrnetmask",
  "cidrsubnet",
  "cidrsubnets",
  "abs",
  "ceil",
  "floor",
  "log",
  "max",
  "min",
  "parseInt",
  "pow",
  "signum",
  "chomp",
  "format",
  "formatlist",
  "indent",
  "join",
  "lower",
  "regexall",
  "regex",
  "replace",
  "split",
  "strrev",
  "substr",
  "title",
  "trim",
  "trimprefix",
  "trimsuffix",
  "trimspace",
  "upper",
  "can",
  "nonsensitive",
  "sensitive",
  "tobool",
  "tolist",
  "tomap",
  "tonumber",
  "toset",
  "tostring",
  "try",
];
// fakes the sort order, our existing terraform-functions.ts file has
// this makes it easier to compare the generated file to the existing function bindings
function fakeSameSortOrderAsExistingFile(
  [a]: [string, ...any[]],
  [b]: [string, ...any[]]
): number {
  return old.indexOf(a) - old.indexOf(b);
}
